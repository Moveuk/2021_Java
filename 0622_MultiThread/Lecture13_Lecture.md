# 멀티 스레드 (MultiThread)


<hr/>
   
## 교재 576p : 12.1 멀티 스레드 개념

### 교재 576p : 12.1.1 프로세스와 스레드

 프로세스 : 운영체제에서 실행 중인 하나의 애플리케이션.
 멀티 태스킹(multi tasking) : 두 가지 이상의 작업을 동시에 처리하는 것.
 스레드(thread) : 사전적 의미로 `한 가닥의 실` 이라는 뜻인데, 한 가지 작업을 실행하기 위해 순차적으로 실행할 코드를 `실`처럼 이어 놓았다고 해서 유래된 이름임.   
   
 멀티 프로세스가 애플리케이션 단위의 멀티 태스킹이라면 멀티 스레드는 애플리케이션 내부에서의 멀티 태스킹이라고 볼 수 있다.   
   
![image](https://user-images.githubusercontent.com/84966961/122843654-e7799180-d33a-11eb-9a19-0a8ea4c1dcb3.png)   
   
 위 그림을 보면 스레드끼리는 스택만을 비공유하고 데이터 영역, 힙 영역은 공유 중인 것을 알 수 있다. `멀티 프로세스` 기반으로 프로그래밍할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만 `멀티 쓰레딩`을 기반으로 프로그래밍할 때는 이 부분을 신경써줘야 한다.   
   
 서로 다른 쓰레드가 `데이터와 힙 영역을 공유`하기 때문에 어떤 쓰레드가 다른 쓰레드에서 사용중인 변수나 자료 구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있기 때문에 주의해야 한다. 그렇기 때문에 멀티 쓰레딩 환경에서는 `동기화 작업`이 필요하다. 동기화를 통해 `작업 처리 순서`를 컨트롤하고 `공유 자원`에 대한 접근을 컨트롤하는 것이다. 하지만 이로 인해 `병목 현상`이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 `락(lock)`으로 인한 병목 현상을 줄여야 한다.    
    
 공유 자원이 아닌 부분은 동기화 처리 할 필요가 없다. 즉, 동기화 처리가 필요한 부분에만 `synchronized` 키워드를 통해 동기화하는 것이다. 불필요한 부분까지 동기화를 할 경우, 현재 쓰레드는 `락(lock)을 획득한 쓰레드가 종료하기 전까지 대기`해야한다. 그렇게 되면 전체 성능에 영향을 미치게 된다. 즉, 동기화를 하고자 할 때는 `메소드 전체를 동기화 할 것인가 아니면 특정 부분만을 동기화할 것인지 고민`해야 한다.

<br/><br/>
<hr/>

## 교재 579p : 12.2 작업 스레드 생성과 실행   
   
![image](https://user-images.githubusercontent.com/84966961/122844352-7509b100-d33c-11eb-8fc1-98ea24f631d3.png)
   
 스레드를 생성 하는 방법은 `java.lang.Thread 클래스를 직접 객체화(Runnable 상속)`해서 생성해도 되지만, `Thread를 상속`해서 하위  클래스를 만들어 생성할 수도 있다.

<br/><br/>
<hr/>

### 교재 579p : 12.2.1 작업 스레드 생성과 실행   
    
 Runnable을 구현한 클래스를 Thread 객체로 생성해주어야 실제 스레드가 생성된다.

```java
Runnable task = new Task();

Thread thread = new Thread(task); // 구현 클래스를 매개 변수로 넣어 스레드를 구체화함.
```
   
 혹은 코드를 좀 더 절약하기 위해 Thread 생성자를 호출할 때 Runnable 익명 객체를 매개값으로 사용할 수 있다. 오히려 이 방법이 많이 사용된다.   
   
```java
Thread thread = new Thread( new Runnable() { 		// 익명 구현 객체.
	public void run() {
		// 스레드가 실행할 코드;
	}
} );
```
 함수적 인터페이스가 아닌 람다식을 매개값으로 사용할 수도 있다. 자바 8부터 지원되는 이 방법이 가장 간단한 방법이다.   
   
```java
Thread thread = new Thread( () -> { 		// 익명 구현 객체.
		// 스레드가 실행할 코드;
	}
} );
```
   

 작업 스레드 만들고 나서 즉시 실행되는 것이 아니라 `start()` 메소드를 다음과 같이 호출해야만 비로소 실행된다.   
   
```java
	thread.start();
```
   
 `start()` 메소드가 호출되면, 작업 스레드는 매개값으로 받은 `unnable의 run() 메소드`를 실행하면서 자신의 작읍을 처리한다.   
   
 스택 구조에 의해서 run() 메소드를 실행하면 기존의 스택에 쌓아가면서 실행을 하게 된다. 그렇기 때문에 run()메소드를 실행하는 것이 아니라 start() 메소드를 실행하여 새로운 스택을 쌓아 실행되도록 하는 것이다.   
   
![image](https://user-images.githubusercontent.com/84966961/122845191-15140a00-d33e-11eb-9d3a-4ba330acbeeb.png)   
   
 이렇게 사용하게 되면 main()과 run()이 두 스택을 통해 공존하는 상태가 된다. run()이 다 실행되고 나면 사라지고 main()으로 돌아가게 된다. thread가 thread를 만들면 자식부터 실행되고 자식 스레드부터 연쇄적으로 종료되게 된다.   
   
![image](https://user-images.githubusercontent.com/84966961/122845440-c024c380-d33e-11eb-8a0a-20b3a550c697.png)   
   
 이런 방식으로 작동하게 만들기 위해서 단순히 run()을 실행시키는 것이 아닌 스레드의 start() 메소드를 사용하는 것이다.   
   







<br/><br/>
<hr/>

### 교재 583p : 12.2.2 Thread 하위 클래스로부터 생성   
       
 




















